
#I used a esp32-c3 super mini for this. I had some already and I like it because it is compact. There are esp boards with the display built in.  
esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # This output power actually lowers the signal strength but apparently slightly lowing it makes it more stable. maybe?
  output_power: 17dB
  # some variables to use with the display and key collector
globals:
  - id: pin_string
    type: std::string
    initial_value: ""
  - id: hidden_string
    type: std::string
    initial_value: ""

captive_portal:

# The Web server is helpful with troubleshooting this device. Lets you see what is going on locally at the controller. For more security might want to comment out. 
web_server:
  port: 80
  include_internal: true

# Text Sensor is getting the alarmo status and then converting that to look nice. 
text_sensor:
  - platform: homeassistant
    entity_id: alarm_control_panel.alarmo
    name: Alarm State
    id: alarm_status
    
  - platform: template
    name: "Display Status"
    id: display_status
    update_interval: 3000ms
    lambda: |-
      if (id(alarm_status).state == "disarmed") {
        return std::string("Disarmed");
      } else if (id(alarm_status).state == "armed_away") {
        return std::string("Armed Away");
      } else if (id(alarm_status).state == "armed_home") {
        return std::string("Armed Home");
      } else if (id(alarm_status).state == "arming") {
        return std::string("Arming");
      } else if (id(alarm_status).state == "pending") {
        return std::string("Pending");
      } else if (id(alarm_status).state == "triggered") {
        return std::string("Triggered");
      } else {
        return std::string("");
      }
   
# font be sure to load one in your esphome folder "*.ttf" . Direct connection to google fonts is available but it might be best to download and make local.  
font:
  - file: "Roboto-Regular.ttf"
    id: font20
    size: 20

# Display
i2c:
  sda: GPIO8
  scl: GPIO9

display:
  - platform: ssd1306_i2c
    id: oled1
    model: "SSD1306 128x64"
    update_interval: 1000ms
    address: 0x3C
    #change hidden_string to pin_string if you want to visually see the pin
    lambda: |-
      it.printf(64, 12, id(font20), TextAlign::TOP_CENTER, "%s", id(display_status).state.c_str());
      it.printf(64, 40, id(font20), TextAlign::TOP_CENTER, "%s", id(hidden_string).c_str());

# Keypad Matrix
matrix_keypad:
  id: mykeypad
  rows:
    - pin: GPIO4
    - pin: GPIO5
    - pin: GPIO6
    - pin: GPIO7
  columns:
    - pin: GPIO0
    - pin: GPIO1
    - pin: GPIO2
    - pin: GPIO3
  keys: "123A456B789C*0#D"
  has_diodes: False

# This is to pass the A key to home assistant to make an automation arm alarmo. I do not use codes to arm. 
binary_sensor:
  - platform: matrix_keypad
    keypad_id: mykeypad
    name: "Key A"
    id: keyA
    key: A

# Key Collector
key_collector:
  - id: pincode_reader
    source_id: mykeypad
    min_length: 4
    max_length: 4
    end_keys: "D"
    end_key_required: True
    back_keys: "*"
    clear_keys: "C"
    allowed_keys: "0123456789"
    timeout: 5s
    on_progress:
      - logger.log:
          format: "input progress: '%s', started by '%c'"
          args: [ 'x.c_str()', "(start == 0 ? '~' : start)" ]
      - lambda: |-
          id(pin_string) = x.c_str();
          id(hidden_string) = std::string(x.length(),'*').c_str();
      - switch.turn_on: buzzer
      - delay: 100ms
      - switch.turn_off: buzzer
    on_result:
      - logger.log:
          format: "input result: '%s', started by '%c', ended by '%c'"
          args: [ 'x.c_str()', "(start == 0 ? '~' : start)", "(end == 0 ? '~' : end)" ]
      - lambda: |-
          id(pin_string) = x.c_str();
          id(hidden_string) = std::string(x.length(),'*');
      #this is the event that passes the pin code. Use this event to trigger an automation for disarming alarmo.
      - homeassistant.event:
          event: esphome.keypad_code_entered
          data:
            code: !lambda "return std::string(x.begin(), x.end());"
    on_timeout:
      - logger.log:
          format: "input timeout: '%s', started by '%c'"
          args: [ 'x.c_str()', "(start == 0 ? '~' : start)" ]
      - switch.turn_on: buzzer
      - delay: 200ms
      - switch.turn_off: buzzer
      - delay: 100ms
      - switch.turn_on: buzzer
      - delay: 200ms
      - switch.turn_off: buzzer

#This is to make the little beeps for button presses or for if the code is no good or times out. 
switch:
  - platform: gpio
    pin:
      number: GPIO10
      inverted: false
    name: "Buzzer"
    id: buzzer



